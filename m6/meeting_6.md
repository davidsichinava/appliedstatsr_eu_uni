<div class="header" style="margin-top:0 px;font-size:60%;">სმდაRგ: მეექვსე შეხვედრა</div>

სტატისტიკურ მონაცემთა დამუშავება და ანალიზი R-ის გარემოში
========================================================
author: დავით სიჭინავა
date: 6 მარტი, 2023 წ.
autosize: true
transition: none
css: css/style.css
font-family: 'BPG_upper'
<span style="font-weight:bold; font-family:BPG_upper;">მეექვსე შეხვედრა</span>



დღევანდელი შეხვედრის გეგმა
========================================================
- წრფივი რეგრესიის დაშვებები
- წრფივი რეგრესიის დიაგნოსტირება


დაშვება:
========================================================
* ცდომილებათა დამოუკიდებლობა
* წრფივი ურთიერთდამოკიდებულება
* ჰომოსკედასტურობა
* ნორმალური განაწილება
* ცდომილებათა საშუალო


რელიგიურობა და ბედნიერება
========================================================

```r
religion_model <- lm(n1~d13, data=cb2017)
summary(religion_model)
```

ნაბიჯი 1: ცდომილობები და პროგნოზირებული მნიშვნელობები
========================================================
* ცდომილობები დამოუკიდებელი უნდა იყოს, ანუ - კორელაციაში არ უნდა იმყოფებოდეს პროგნოზირებულ მნიშვნელობებთან


```r
plot(religion_model)
```



უკიდურესი წერტილები
========================================================
* outlierTest გვიჩვენებს, თუ მერამდენე ჩანაწერია ყველაზე ,,ექსტემალური'', რომელიც დიდ გავლენას ახდენს მოდელის ხარისხზე



```r
outlierTest(religion_model)
```

გავლენიანი ჩანაწერები
========================================================
* leveragePlots გვიჩვენებს, თუ რომელი ჩანაწერები ,,ექაჩებიან''  მოდელს, რაც იმაზე მიგვითითებს, რომ რეგრესიის წრფე ამ შემთხვევების გავლენით, ოპტიმალურისგან შორს მდებარეობს.


```r
leveragePlots(religion_model)
```

```r
# კუკის მანძილის დიაგრამები
# D მნიშვნელობის განსაზღვრა > 4/(n-k-1) 
cutoff <- 4/((nrow(face)-length(religion_model$coefficients)-2))
```
* ამ შემთხვევაში, ჩვენი ამოცანაა, პოტენციური პრობლემის აღმოსაფხვრელად შევისწავლოთ ყველა ის ჩანაწერი, რომელიც cutoff მნიშვნელობას აღემატება.


```r
plot(religion_model, which=4, cook.levels=cutoff)
```

ცდომილებათა ნორმალურობა
========================================================
* გარდა ზემოთ აღწერილი მეთოდისა, ცდომილებათა ნორმალურობის შესწავლა შესაძლებელია, თუ ნაწინასწარმეტყველებ ცდომილებებს ,,სტიუდენტიზაციას'' გავუკეთებთ, ანუ - მოვახდენთ მის სტანდარტიზაციას სტანდარტული გადახრის მეშვეობით. 


```r
library(MASS)
sresid <- studres(religion_model) 
hist(sresid, freq=FALSE, 
   main="სტუდენტიზებული ცდომილებების განაწილება")
```

არამუდმივ ცდომილებათა დისპერსია (ჰეტეროსკედასტურობა)
========================================================

```r
### ამ შემთხვევაში, უნდა გამოვიყენოთ lmtest ბიბლიოთეკა და ბრეუშ-პაგანის ტესტი
bptest(religion_model)
```

* ბრეუშ-პაგანის ტესტის ნულოვანი ჰიპოთეზა არის ის, რომ ცდომილებათად დისპერსია არ არის დამოკიდებული გარე ფაქტორებზე. შესაბამისად, თუ p-მნიშვნელობა მცირეა, ნულოვანი ჰიპოთზა უნდა უარვყოთ და ჩავთვალოთ, რომ ჩვენს მონაცემებს ჰომოსკედასტურობის პრობლემა აქვს.

* თუ მონაცემები ჰეტეროსკედასტურია, შესაბამისად, გამოთვლილი სტანდარტული შეცდომა არასწორია. პრობლემის აღმოსაფხვრელად როგორც წესი, ე.წ. რობასტულ (robust) რეგრესიულ მოდელებს იყენებენ

```

მულტიკოლინეარულობა
========================================================

* მრავალწევრი რეგრესიული მოდელის ერთ-ერთი დაშვება არის ის, რომ დამოუკიდებელ ცვლადებს შორის წრფივი დამოკიდებულება არ უნდა იყოს, ან - მცირე დონეზე. თუმცა ეს პირობა ცხოვრებაში არასდროს სრულდება;

* მულტიკოლინეარულობის აღმოჩენის ყველაზე მარტივი ხერხი ამხსნელ ცვლადებს შორის კორელაციის გამოთვლაა. თუმცა ასევე შესაძლებელია ე.წ. დისპერსიის ინფლაციის მაჩვენებლის გამოთვლაა


```r
vif(religion_model) # დისპერსიის ინფლაციის ფაქტორი 
sqrt(vif(religion_model)) > 2 # პრობლემატური შემთხვევები
```

მულტიკოლინეარულობა
========================================================
* როგორ მოვაგვაროთ პრობლემა? საჭიროა, გადავხედოთ მოდელის ამხსნელ ცვლადებს და დავრწმუნდეთ, ერთმანეთთან კორელაციაში მყოფი ცვლადები ერთსა და იმავე ფენომენს ზომავენ. თუ თეორიული თვალსაზრისით ასეა, მაშინ შეგვიძლია, ერთ-ერთი რომელიმე ცვლადი რეგრესიული მოდელიდან ამოვიღოთ 


ცდომილებათა ავტოკორელაცია
========================================================
* როდესაც საქმე დროითი მწკრივების მონაცემებთან გვაქვს, ხშირ შემთხვევაში, მონაცემები _წინა ტალღის_ მონაცემებზეა დამოკიდებული (მაგ. მშპ, გაყიდვები და ა.შ.)
* დაშვება მოწმდება დურბინ-ვოტსონის ტესტით, lmtest ბიბლიოთეკიდან
* ამ შემთხვევაში, მოდელში უნდა ჩავსვათ _ბიჯის_ დამატებითი ცვლადი

ცდომილებათა ავტოკორელაცია
========================================================

```r
tourism <- read.csv("tourism.csv")
t_mod <- lm(BorderCrossing~Cards)
lmtest::dwtest(t_mod)

tourism$lag <- dplyr::lag(tourism$Cards)
t_mod <- lm(BorderCrossing~Cards+lag, data=tourism)
```



